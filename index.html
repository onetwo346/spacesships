<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cosmic Horizon: Moreland's Dominion</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { min-height: 100vh; min-width: 100vw; }
        body, html { overflow: hidden; width: 100vw; height: 100vh; font-family: 'Comic Sans MS', 'Arial', sans-serif; background: #0a0a1e; color: #fff; touch-action: none; }
        #intro, #option-mode { 
            position: absolute; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; 
            background: radial-gradient(circle at center, #1e1e3c 0%, #0a0a1e 70%); z-index: 200; animation: pulseBackground 10s infinite alternate; 
        }
        #option-mode { display: none; }
        @keyframes pulseBackground { 0% { background: radial-gradient(circle at center, #1e1e3c 0%, #0a0a1e 70%); } 100% { background: radial-gradient(circle at center, #2a2a5a 0%, #0a0a1e 70%); } }
        
        /* Responsive font sizes using vw units */
        #intro h1, #option-mode h1 { 
            font-size: clamp(2rem, 8vw, 5rem); 
            text-transform: uppercase; 
            color: #00d4ff; 
            text-shadow: 0 0 10px #00d4ff, 0 0 20px #ff00ff, 0 0 30px #00d4ff; 
            animation: glowText 2s infinite alternate; 
            border: 4px solid #fff; 
            padding: clamp(10px, 2vw, 20px); 
            background: rgba(0, 0, 0, 0.7); 
            transform: skew(-5deg); 
            margin: 0 auto;
            text-align: center;
        }
        
        @keyframes glowText { 0% { text-shadow: 0 0 10px #00d4ff, 0 0 20px #ff00ff; } 100% { text-shadow: 0 0 20px #00d4ff, 0 0 40px #ff00ff; } }
        
        #intro p, #option-mode p { 
            font-size: clamp(1rem, 3vw, 1.5rem); 
            max-width: min(90%, 600px); 
            text-align: center; 
            margin: clamp(10px, 2vw, 20px) 0; 
            color: #aaaaff; 
            text-shadow: 0 0 5px #aaaaff; 
            padding: 0 20px;
        }
        
        #start-button, .option-button, #enter-button, #generate-code, #join-game { 
            margin: clamp(5px, 1vw, 10px); 
            padding: clamp(8px, 2vw, 15px) clamp(15px, 3vw, 30px); 
            font-size: clamp(1rem, 3vw, 1.8rem); 
            color: #fff; 
            background: linear-gradient(45deg, #ff00ff, #00d4ff); 
            border: 5px solid #fff; 
            border-radius: 15px; 
            text-transform: uppercase; 
            cursor: pointer; 
            box-shadow: 0 0 15px #ff00ff, 0 0 25px #00d4ff; 
            animation: pulseButton 1.5s infinite; 
            transform: skew(-10deg); 
            white-space: nowrap;
        }
        
        #start-button:hover, .option-button:hover, #enter-button:hover, #generate-code:hover, #join-game:hover { 
            background: linear-gradient(45deg, #00d4ff, #ff00ff); 
            box-shadow: 0 0 25px #ff00ff, 0 0 35px #00d4ff; 
        }
        
        @keyframes pulseButton { 
            0% { transform: skew(-10deg) scale(1); box-shadow: 0 0 15px #ff00ff; } 
            50% { transform: skew(-10deg) scale(1.05); box-shadow: 0 0 25px #00d4ff; } 
            100% { transform: skew(-10deg) scale(1); box-shadow: 0 0 15px #ff00ff; } 
        }
        
        #ship-selection, #color-selection, #multiplayer-options { 
            display: flex; 
            flex-wrap: wrap; 
            justify-content: center; 
            gap: clamp(10px, 2vw, 20px); 
            margin: clamp(10px, 2vw, 20px) 0; 
            padding: 0 20px;
        }
        
        .ship-option, .color-option { 
            width: clamp(60px, 15vw, 100px); 
            height: clamp(60px, 15vw, 100px); 
            border: 3px solid #fff; 
            border-radius: 10px; 
            cursor: pointer; 
            transition: transform 0.3s; 
        }
        
        .ship-option:hover, .color-option:hover { transform: scale(1.1); }
        .ship-option.selected, .color-option.selected { border-color: #00d4ff; box-shadow: 0 0 15px #00d4ff; }
        
        #join-game-input { 
            padding: clamp(5px, 1vw, 10px); 
            font-size: clamp(1rem, 3vw, 1.5rem); 
            border: 3px solid #fff; 
            border-radius: 10px; 
            background: rgba(0, 0, 0, 0.7); 
            color: #fff; 
            width: min(90%, 300px);
        }
        
        #generated-code { 
            font-size: clamp(1rem, 3vw, 1.5rem); 
            color: #00d4ff; 
            text-shadow: 0 0 5px #00d4ff; 
            margin: 10px; 
        }
        
        #footer { 
            position: absolute; 
            bottom: 20px; 
            width: 100%; 
            text-align: center; 
            font-size: clamp(0.8rem, 2vw, 1.2rem); 
            color: #aaaaff; 
            text-shadow: 0 0 5px #aaaaff; 
            letter-spacing: 2px; 
            padding: 0 20px;
        }
        
        #canvas { 
            position: absolute; 
            top: env(safe-area-inset-top,0); 
            left: env(safe-area-inset-left,0); 
            width: calc(100vw - env(safe-area-inset-left,0) - env(safe-area-inset-right,0)); 
            height: calc(100vh - env(safe-area-inset-top,0) - env(safe-area-inset-bottom,0)); 
            z-index: 1; 
            display: none; 
        }
        
        #instructions { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            background: rgba(0, 0, 50, 0.7); 
            padding: 10px 15px; 
            border-radius: 5px; 
            color: #fff; 
            z-index: 10; 
            max-width: min(90%, 350px); 
            font-size: clamp(0.8rem, 2vw, 1rem);
            text-shadow: 0 0 3px #00d4ff; 
        }
        
        #pause-menu { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            background: rgba(0, 0, 50, 0.9); 
            padding: 20px; 
            border-radius: 10px; 
            z-index: 100; 
            display: none; 
            text-align: center; 
        }
        
        #race-status { 
            position: absolute; 
            top: 20px; 
            right: 20px; 
            color: #00d4ff; 
            font-size: clamp(1rem, 3vw, 1.5rem); 
            z-index: 10; 
        }
        
        /* Touch Controls Layout */
        #joystick-left-container, #joystick-right-container {
            position: absolute;
            bottom: clamp(20px, 5vw, 30px);
            z-index: 12;
        }
        
        #joystick-left-container {
            left: clamp(20px, 5vw, 30px);
        }
        
        #joystick-right-container {
            right: clamp(20px, 5vw, 30px);
        }
        
        .joystick {
            width: clamp(60px, 15vw, 90px);
            height: clamp(60px, 15vw, 90px);
            background: radial-gradient(circle, rgba(0,212,255,0.25), rgba(0,0,50,0.5));
            border-radius: 50%;
            box-shadow: 0 0 8px #00d4ff;
            position: relative;
            touch-action: none;
        }
        
        #touch-buttons {
            position: absolute;
            right: clamp(20px, 5vw, 30px);
            bottom: clamp(100px, 20vw, 130px);
            display: flex;
            flex-direction: column;
            gap: clamp(8px, 2vw, 16px);
            z-index: 13;
        }
        
        .touch-btn {
            width: clamp(50px, 12vw, 72px);
            height: clamp(35px, 8vw, 48px);
            background: linear-gradient(45deg, #00d4ff, #ff00ff);
            color: #fff;
            border: none;
            border-radius: 8px;
            font-size: clamp(0.8rem, 2vw, 1.1rem);
            box-shadow: 0 0 10px #00d4ff;
            text-shadow: 0 0 3px #ff00ff;
            margin-bottom: 6px;
        }
        
        .touch-btn:active { background: linear-gradient(45deg, #ff00ff, #00d4ff); }
        
        /* Safe area for notched devices */
        body { 
            padding-top: env(safe-area-inset-top,0); 
            padding-bottom: env(safe-area-inset-bottom,0); 
            padding-left: env(safe-area-inset-left,0); 
            padding-right: env(safe-area-inset-right,0); 
        }
    </style>
</head>
<body>
    <div id="intro">
        <h1>Cosmic Horizon</h1>
        <p>Rule Moreland's boundless expanse—valleys, waterfalls, and mist weaving earth to sky—blazing at warp speed in this retro-futuristic epic!</p>
        <div id="start-button">Tap to Start</div>
        <div id="footer">Designed by Nana Kofi cosmoscoderr@gmail.com</div>
    </div>

    <div id="option-mode">
        <h1>Choose Your Ride</h1>
        <div id="ship-selection"></div>
        <div id="color-selection"></div>
        <div class="option-button" id="solo-mode">Solo Free Fly</div>
        <div id="multiplayer-options">
            <div>
                <div id="join-game">Join Game</div>
                <input type="text" id="join-game-input" placeholder="Enter Code">
            </div>
            <div class="option-button" id="multiplayer-mode">Multiplayer</div>
            <div>
                <div id="generate-code">Generate Code</div>
                <div id="generated-code"></div>
            </div>
        </div>
        <div id="enter-button">Enter</div>
    </div>

    <div id="instructions">
        W/S: Thrust forward/back (Double-tap W for warp) | A/D: Strafe | P: Pause | Esc: Quit | G: Shoot | Joystick/Mouse: Look | Arrow keys: Rotate | +/-: Zoom | Space: Up (3s+ to blast) | Shift: Down | R: Toggle Race
    </div>
    <canvas id="canvas"></canvas>
    <div id="joystick-left-container">
        <div id="joystick-left" class="joystick"></div>
    </div>
    <div id="joystick-right-container">
        <div id="joystick-right" class="joystick"></div>
    </div>
    <div id="touch-buttons">
        <button class="touch-btn" id="btn-shoot">Shoot</button>
        <button class="touch-btn" id="btn-jump">Up</button>
        <button class="touch-btn" id="btn-down">Down</button>
        <button class="touch-btn" id="btn-boost">Boost</button>
        <button class="touch-btn" id="btn-pause">Pause</button>
    </div>
    <div id="joystick-container">
        <div id="joystick"></div>
    </div>
    <div id="pause-menu">
        <h2>Paused</h2>
        <div class="option-button" id="resume-button">Resume</div>
        <div class="option-button" id="quit-button">Quit</div>
    </div>
    <div id="race-status"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script>
        const intro = document.getElementById('intro');
        const optionMode = document.getElementById('option-mode');
        const canvas = document.getElementById('canvas');
        const startButton = document.getElementById('start-button');
        const shipSelection = document.getElementById('ship-selection');
        const colorSelection = document.getElementById('color-selection');
        const soloMode = document.getElementById('solo-mode');
        const multiplayerMode = document.getElementById('multiplayer-mode');
        const generateCodeButton = document.getElementById('generate-code');
        const joinGameButton = document.getElementById('join-game');
        const joinGameInput = document.getElementById('join-game-input');
        const generatedCodeDisplay = document.getElementById('generated-code');
        const enterButton = document.getElementById('enter-button');
        const pauseMenu = document.getElementById('pause-menu');
        const resumeButton = document.getElementById('resume-button');
        const quitButton = document.getElementById('quit-button');
        const raceStatus = document.getElementById('race-status');

        let selectedShip = null, selectedColor = null, gameMode = null, gameCode = null, isPaused = false, isHost = false;
        let peer = null, connections = [], myId = null, peerShips = {}, isRaceMode = false, raceStartTime = 0, raceFinishLine;

        const ships = [
            { name: 'Classic', perk: 'Balanced', color: 0xaaaaaa, gun: 'Standard', speed: 8.0 },
            { name: 'Blaster', perk: 'Rapid Fire', color: 0xff5555, gun: 'Rapid', speed: 8.2 },
            { name: 'Tank', perk: 'High Durability', color: 0x5555ff, gun: 'Heavy', speed: 8.0 },
            { name: 'Stealth', perk: 'Fast Reload', color: 0x55ff55, gun: 'Quick', speed: 8.1 },
            { name: 'Sniper', perk: 'Long Range', color: 0xffff55, gun: 'Sniper', speed: 8.0 },
            { name: 'Bomber', perk: 'Explosive Shots', color: 0xff55ff, gun: 'Explosive', speed: 8.2 }
        ];
        const colors = [0xaaaaaa, 0xff5555, 0x5555ff, 0x55ff55, 0xffff55, 0xff55ff];

        ships.forEach((ship, index) => {
            const div = document.createElement('div');
            div.className = 'ship-option';
            div.style.backgroundColor = `#${ship.color.toString(16).padStart(6, '0')}`;
            div.innerText = ship.name;
            function selectShip() {
                document.querySelectorAll('.ship-option').forEach(opt => opt.classList.remove('selected'));
                div.classList.add('selected');
                selectedShip = index;
            }
            div.addEventListener('click', selectShip);
            shipSelection.appendChild(div);
        });

        colors.forEach(color => {
            const div = document.createElement('div');
            div.className = 'color-option';
            div.style.backgroundColor = `#${color.toString(16).padStart(6, '0')}`;
            function selectColor() {
                document.querySelectorAll('.color-option').forEach(opt => opt.classList.remove('selected'));
                div.classList.add('selected');
                selectedColor = color;
            }
            div.addEventListener('click', selectColor);
            colorSelection.appendChild(div);
        });

        startButton.addEventListener('click', () => {
            intro.style.display = 'none';
            optionMode.style.display = 'flex';
        });

        soloMode.addEventListener('click', () => { 
            gameMode = 'solo'; 
            soloMode.style.background = '#00d4ff'; 
            multiplayerMode.style.background = ''; 
            gameCode = null; 
            generatedCodeDisplay.innerText = ''; 
            joinGameInput.value = '';
            isHost = false;
        });

        multiplayerMode.addEventListener('click', () => { 
            gameMode = 'multiplayer'; 
            multiplayerMode.style.background = '#00d4ff'; 
            soloMode.style.background = ''; 
        });

        generateCodeButton.addEventListener('click', () => {
            if (gameMode === 'multiplayer') {
                gameCode = Math.random().toString(36).substr(2, 6).toUpperCase();
                generatedCodeDisplay.innerText = `Code: ${gameCode}`;
                isHost = true;
            }
        });

        joinGameButton.addEventListener('click', () => {
            if (gameMode === 'multiplayer' && joinGameInput.value) {
                gameCode = joinGameInput.value.toUpperCase();
                generatedCodeDisplay.innerText = `Joining: ${gameCode}`;
                isHost = false;
            }
        });

        function triggerEnter() {
            console.log('[triggerEnter] selectedShip:', selectedShip, 'selectedColor:', selectedColor, 'gameMode:', gameMode, 'gameCode:', gameCode);
            console.log('[triggerEnter] optionMode:', optionMode, 'canvas:', canvas);
            if (selectedShip === null || selectedColor === null) {
                alert('Please select a ship and color!');
                return;
            }
            if (gameMode === 'solo' || (gameMode === 'multiplayer' && gameCode)) {
                optionMode.style.display = 'none';
                canvas.style.display = 'block';
                try {
                    init();
                } catch (err) {
                    alert('Error during game initialization: ' + err);
                    console.error('Error during init():', err);
                }
            } else if (gameMode === 'multiplayer') {
                alert('Please generate a code or join a game first!');
            }
        }
        enterButton.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            triggerEnter();
        });

        resumeButton.addEventListener('click', () => togglePause(false));
        quitButton.addEventListener('click', () => {
            isPaused = false;
            pauseMenu.style.display = 'none';
            canvas.style.display = 'none';
            optionMode.style.display = 'flex';
            cleanupMultiplayer();
        });

        let camera, scene, renderer, ship, skyMaterial, fogMaterial, cosmicLights = [], npcShips = [], waterfalls = [], fogParticles, obstacles = [], bullets = [];
        let velocity = new THREE.Vector3();
        let maxSpeed = ships[0].speed, baseAccel = 2.0, boostAccel = 6.0, friction = 0.95, liftSpeed = 4.0, blastSpeed = 40, verticalSpeed = 4.0;
        let keys = { w: false, s: false, a: false, d: false, space: false, shift: false, p: false, g: false, escape: false, r: false };
        let isUserInteracting = false, onPointerDownMouseX = 0, onPointerDownMouseY = 0, lon = 0, onPointerDownLon = 0, lat = 0, onPointerDownLat = 0, targetLon = 0, targetLat = 0, phi = 0, theta = 0;
        let joystick, joystickRect, joystickCenterX, joystickCenterY, joystickActive = false, joystickTouchId = null;
        let time = 0, spaceHoldTime = 0, cycleTime = 0, cameraDistance = 15, cameraHeight = 5, lastWTime = 0, wTapCount = 0, boostEndTime = 0;
        let clock = new THREE.Clock();
        let leftJoystick, rightJoystick, leftActive = false, rightActive = false, leftStart = { x: 0, y: 0 }, rightStart = { x: 0, y: 0 }, leftDelta = { x: 0, y: 0 }, rightDelta = { x: 0, y: 0 };

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 4000);
            camera.position.set(0, 10, 15);

            // Mobile-optimized renderer settings
            renderer = new THREE.WebGLRenderer({ 
                canvas, 
                antialias: !isMobileDevice(), // Disable antialiasing on mobile
                powerPreference: "low-power", // Prefer power saving over performance
                precision: isMobileDevice() ? "lowp" : "highp" // Use low precision on mobile
            });
            
            // Set pixel ratio with a cap for mobile devices
            const maxPixelRatio = isMobileDevice() ? 2 : window.devicePixelRatio;
            renderer.setPixelRatio(Math.min(maxPixelRatio, window.devicePixelRatio || 1));
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Optimize shadow settings for mobile
            renderer.shadowMap.enabled = !isMobileDevice();
            renderer.shadowMap.autoUpdate = false; // Disable automatic shadow updates
            renderer.shadowMap.type = THREE.BasicShadowMap; // Use basic shadows for better performance

            maxSpeed = ships[selectedShip].speed;
            createCosmicSky();
            createTerrain();
            createVolumetricFog();
            createShip();
            createSkyscraper();
            createNPCShips();
            createObstacles();
            if (isHost && gameMode === 'multiplayer') createRaceFinishLine();
            setupJoystick();
            setupControls();

            // Optimize for mobile
            if (isMobileDevice()) {
                scene.fog = new THREE.Fog(0x000000, 100, 1000); // Add fog for performance
                renderer.setClearColor(0x000000); // Set black background
            }

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('pointerdown', onPointerDown);
            document.addEventListener('pointermove', onPointerMove);
            document.addEventListener('pointerup', onPointerUp);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            if (gameMode === 'multiplayer') setupMultiplayer();
            animate();
        }

        function setupMultiplayer() {
            console.log('Setting up multiplayer...');
            peer = new Peer(isHost ? gameCode : null, {
                debug: 2 // Enable PeerJS debug logs
            });

            peer.on('open', (id) => {
                myId = id;
                console.log(`Peer opened with ID: ${id}, isHost: ${isHost}, Code: ${gameCode}`);
                if (!isHost) {
                    console.log(`Attempting to connect to host with code: ${gameCode}`);
                    const conn = peer.connect(gameCode, { reliable: true });
                    setupConnection(conn);
                }
            });

            peer.on('connection', (conn) => {
                console.log(`Incoming connection from ${conn.peer}`);
                if (isHost) {
                    setupConnection(conn);
                }
            });

            peer.on('error', (err) => {
                console.error('PeerJS Error:', err.type, err);
                if (err.type === 'peer-unavailable') {
                    alert('Host not found! Check the code and try again.');
                    cleanupMultiplayer();
                    optionMode.style.display = 'flex';
                    canvas.style.display = 'none';
                }
            });

            // Start syncing after a short delay to ensure ship exists
            setTimeout(() => {
                console.log('Starting position sync...');
                setInterval(syncShipData, 33); // ~30 FPS
            }, 1000);
        }

        function setupConnection(conn) {
            connections.push(conn);
            conn.on('open', () => {
                console.log(`Connection established with ${conn.peer}`);
                const initialData = {
                    type: 'init',
                    id: myId,
                    color: selectedColor,
                    pos: ship ? ship.position.toArray() : [0, 100, 0],
                    rot: ship ? ship.rotation.toArray() : [0, 0, 0]
                };
                conn.send(initialData);
                console.log(`Sent initial data to ${conn.peer}:`, initialData);
            });

            conn.on('data', (data) => {
                console.log(`Received data from ${conn.peer}:`, data);
                if (data.id && data.pos && data.rot) {
                    updatePeerShip(data);
                }
            });

            conn.on('close', () => {
                console.log(`Connection closed with ${conn.peer}`);
                connections = connections.filter(c => c !== conn);
                if (peerShips[conn.peer]) {
                    scene.remove(peerShips[conn.peer]);
                    delete peerShips[conn.peer];
                    console.log(`Removed ship for ${conn.peer}`);
                }
            });

            conn.on('error', (err) => {
                console.error(`Connection error with ${conn.peer}:`, err);
            });
        }

        function syncShipData() {
            if (!ship || !myId || connections.length === 0 || isPaused) {
                console.log('Sync skipped:', { hasShip: !!ship, hasId: !!myId, connections: connections.length, isPaused });
                return;
            }

            const data = {
                type: 'update',
                id: myId,
                pos: ship.position.toArray(),
                rot: ship.rotation.toArray(),
                color: selectedColor,
                raceMode: isRaceMode,
                raceTime: isRaceMode && isHost ? (performance.now() - raceStartTime) / 1000 : undefined
            };

            connections.forEach(conn => {
                if (conn.open) {
                    conn.send(data);
                    console.log(`Sent update to ${conn.peer}:`, data.pos);
                } else {
                    console.log(`Connection to ${conn.peer} not open`);
                }
            });
        }

        function updatePeerShip(data) {
            const peerId = data.id;
            if (!peerId || peerId === myId) return; // Ignore own data

            if (!peerShips[peerId]) {
                console.log(`Creating new ship for ${peerId}`);
                peerShips[peerId] = createPeerShip(data.color);
                scene.add(peerShips[peerId]); // Ensure it's added to the scene
            }

            const peerShip = peerShips[peerId];
            const targetPos = new THREE.Vector3().fromArray(data.pos);
            peerShip.position.lerp(targetPos, 0.5); // Smooth movement
            peerShip.rotation.fromArray(data.rot);
            console.log(`Updated ${peerId} to pos:`, peerShip.position.toArray());

            if (data.raceMode && !isRaceMode && !isHost) {
                isRaceMode = true;
                if (!raceFinishLine) createRaceFinishLine();
                raceStartTime = performance.now() - (data.raceTime * 1000);
            }
        }

        function createPeerShip(color) {
            const shipGroup = new THREE.Group();
            const baseGeometry = new THREE.CylinderGeometry(3, 2.5, 0.8, 16, 1);
            const baseMaterial = new THREE.MeshPhongMaterial({ color, shininess: 50 });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            shipGroup.add(base);
            const domeGeometry = new THREE.SphereGeometry(1.5, 16, 8);
            const domeMaterial = new THREE.MeshPhongMaterial({ color: 0x00ffaa, transparent: true, opacity: 0.8, shininess: 100 });
            const dome = new THREE.Mesh(domeGeometry, domeMaterial);
            dome.position.y = 0.8;
            shipGroup.add(dome);
            const ringGeometry = new THREE.TorusGeometry(2, 0.2, 6, 16);
            const ringMaterial = new THREE.MeshBasicMaterial({ color, emissive: color });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = -0.1;
            shipGroup.add(ring);
            console.log(`Created peer ship with color ${color.toString(16)}`);
            return shipGroup;
        }

        function cleanupMultiplayer() {
            if (peer) {
                connections.forEach(conn => conn.close());
                peer.destroy();
                peer = null;
                connections = [];
                myId = null;
            }
            Object.values(peerShips).forEach(peerShip => scene.remove(peerShip));
            peerShips = {};
            if (raceFinishLine) scene.remove(raceFinishLine);
            raceFinishLine = null;
            isRaceMode = false;
            raceStatus.innerText = '';
            console.log('Multiplayer cleaned up');
        }

        function createRaceFinishLine() {
            const geometry = new THREE.RingGeometry(20, 25, 32);
            const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
            raceFinishLine = new THREE.Mesh(geometry, material);
            raceFinishLine.position.set(500, 50, 500);
            raceFinishLine.rotation.x = Math.PI / 2;
            scene.add(raceFinishLine);
        }

        function animate() {
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // Skip frame if device is struggling
            if (isMobileDevice() && delta > 0.1) {
                requestAnimationFrame(animate);
                return;
            }

            // Update controls based on device type
            if (isMobileDevice()) {
                // Mobile controls update
                if (leftActive) {
                    ship.position.x += leftDelta.x * MOBILE_MOVE_SPEED * delta;
                    ship.position.z += leftDelta.y * MOBILE_MOVE_SPEED * delta;
                }
                if (rightActive) {
                    ship.rotation.y += rightDelta.x * MOBILE_ROTATION_SPEED * delta;
                    // Limit vertical movement on mobile
                    const newY = ship.position.y + rightDelta.y * MOBILE_MOVE_SPEED * delta;
                    ship.position.y = Math.max(50, Math.min(150, newY));
                }
            } else {
                // Desktop controls update
                // ... existing desktop control code ...
            }

            // Optimize particle updates
            if (particles) {
                if (!isMobileDevice() || time % 2 < 1) { // Update particles every other second on mobile
                    particles.rotation.y += delta * 0.05;
                    const positions = particles.geometry.attributes.position.array;
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i + 1] += Math.sin(time + positions[i] * 0.01) * delta;
                    }
                    particles.geometry.attributes.position.needsUpdate = true;
                }
            }

            // Optimize NPC updates
            const updateInterval = isMobileDevice() ? 2 : 1; // Update NPCs less frequently on mobile
            if (time % updateInterval < delta) {
                npcShips.forEach(npc => {
                    // ... existing NPC update code ...
                });
            }

            // Only update shadows when necessary
            if (!isMobileDevice() && time % 1 < delta) {
                renderer.shadowMap.needsUpdate = true;
            }

            // Render scene
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        // Constants for mobile optimization
        const MOBILE_MOVE_SPEED = 100;
        const MOBILE_ROTATION_SPEED = 2;

        function onKeyDown(event) {
            if (isPaused) return;
            
            switch(event.key.toLowerCase()) {
                case 'w': keys.w = true; break;
                case 's': keys.s = true; break;
                case 'a': keys.a = true; break;
                case 'd': keys.d = true; break;
                case ' ': keys.space = true; break;
                case 'shift': keys.shift = true; break;
                case 'p': togglePause(); break;
                case 'g': shoot(); break;
                case 'escape': quitGame(); break;
                case 'r': toggleRaceMode(); break;
            }
        }

        function onKeyUp(event) {
            switch(event.key.toLowerCase()) {
                case 'w': keys.w = false; break;
                case 's': keys.s = false; break;
                case 'a': keys.a = false; break;
                case 'd': keys.d = false; break;
                case ' ': keys.space = false; break;
                case 'shift': keys.shift = false; break;
            }
        }

        function togglePause() {
            isPaused = !isPaused;
            pauseMenu.style.display = isPaused ? 'block' : 'none';
        }

        function quitGame() {
            isPaused = false;
            pauseMenu.style.display = 'none';
            canvas.style.display = 'none';
            optionMode.style.display = 'flex';
            cleanupMultiplayer();
        }

        function toggleRaceMode() {
            isRaceMode = !isRaceMode;
            if (isRaceMode && isHost) {
                raceStartTime = performance.now();
                if (!raceFinishLine) createRaceFinishLine();
            }
            raceStatus.innerText = isRaceMode ? 'Race Mode: ON' : 'Race Mode: OFF';
        }

        function shoot() {
            if (isPaused) return;
            // Add shooting logic here
        }
    </script>
</body>
</html>
