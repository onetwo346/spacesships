<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cosmic Horizon: Moreland’s Dominion</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { min-height: 100vh; min-width: 100vw; }
        body, html { overflow: hidden; width: 100vw; height: 100vh; font-family: 'Comic Sans MS', 'Arial', sans-serif; background: #0a0a1e; color: #fff; touch-action: none; }
        #intro, #option-mode { 
            position: absolute; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; 
            background: radial-gradient(circle at center, #1e1e3c 0%, #0a0a1e 70%); z-index: 200; animation: pulseBackground 10s infinite alternate; 
        }
        #option-mode { display: none; }
        @keyframes pulseBackground { 0% { background: radial-gradient(circle at center, #1e1e3c 0%, #0a0a1e 70%); } 100% { background: radial-gradient(circle at center, #2a2a5a 0%, #0a0a1e 70%); } }
        #intro h1, #option-mode h1 { font-size: 5rem; text-transform: uppercase; color: #00d4ff; text-shadow: 0 0 10px #00d4ff, 0 0 20px #ff00ff, 0 0 30px #00d4ff; animation: glowText 2s infinite alternate; border: 4px solid #fff; padding: 20px; background: rgba(0, 0, 0, 0.7); transform: skew(-5deg); }
        @keyframes glowText { 0% { text-shadow: 0 0 10px #00d4ff, 0 0 20px #ff00ff; } 100% { text-shadow: 0 0 20px #00d4ff, 0 0 40px #ff00ff; } }
        #intro p, #option-mode p { font-size: 1.5rem; max-width: 600px; text-align: center; margin: 20px 0; color: #aaaaff; text-shadow: 0 0 5px #aaaaff; }
        #start-button, .option-button, #enter-button, #generate-code, #join-game { margin: 10px; padding: 15px 30px; font-size: 1.8rem; color: #fff; background: linear-gradient(45deg, #ff00ff, #00d4ff); border: 5px solid #fff; border-radius: 15px; text-transform: uppercase; cursor: pointer; box-shadow: 0 0 15px #ff00ff, 0 0 25px #00d4ff; animation: pulseButton 1.5s infinite; transform: skew(-10deg); }
        #start-button:hover, .option-button:hover, #enter-button:hover, #generate-code:hover, #join-game:hover { background: linear-gradient(45deg, #00d4ff, #ff00ff); box-shadow: 0 0 25px #ff00ff, 0 0 35px #00d4ff; }
        @keyframes pulseButton { 0% { transform: skew(-10deg) scale(1); box-shadow: 0 0 15px #ff00ff; } 50% { transform: skew(-10deg) scale(1.05); box-shadow: 0 0 25px #00d4ff; } 100% { transform: skew(-10deg) scale(1); box-shadow: 0 0 15px #ff00ff; } }
        #ship-selection, #color-selection, #multiplayer-options { display: flex; flex-wrap: wrap; justify-content: center; gap: 20px; margin: 20px 0; }
        .ship-option, .color-option { width: 100px; height: 100px; border: 3px solid #fff; border-radius: 10px; cursor: pointer; transition: transform 0.3s; }
        .ship-option:hover, .color-option:hover { transform: scale(1.1); }
        .ship-option.selected, .color-option.selected { border-color: #00d4ff; box-shadow: 0 0 15px #00d4ff; }
        #join-game-input { padding: 10px; font-size: 1.5rem; border: 3px solid #fff; border-radius: 10px; background: rgba(0, 0, 0, 0.7); color: #fff; }
        #generated-code { font-size: 1.5rem; color: #00d4ff; text-shadow: 0 0 5px #00d4ff; margin: 10px; }
        #footer { position: absolute; bottom: 20px; width: 100%; text-align: center; font-size: 1.2rem; color: #aaaaff; text-shadow: 0 0 5px #aaaaff; letter-spacing: 2px; }
        #canvas { position: absolute; top: env(safe-area-inset-top,0); left: env(safe-area-inset-left,0); width: calc(100vw - env(safe-area-inset-left,0) - env(safe-area-inset-right,0)); height: calc(100vh - env(safe-area-inset-top,0) - env(safe-area-inset-bottom,0)); z-index: 1; display: none; }
        #joystick-container { position: absolute; bottom: 30px; right: 30px; width: 100px; height: 100px; background: radial-gradient(circle, rgba(255, 255, 255, 0.3), rgba(0, 0, 50, 0.5)); border-radius: 50%; z-index: 10; touch-action: none; }
        #joystick { position: relative; top: 25px; left: 25px; width: 50px; height: 50px; background: radial-gradient(circle, #00d4ff, #1e90ff); border-radius: 50%; box-shadow: 0 0 10px #00d4ff; cursor: pointer; touch-action: none; }
        #instructions { position: absolute; top: 20px; left: 20px; background: rgba(0, 0, 50, 0.7); padding: 10px 15px; border-radius: 5px; color: #fff; z-index: 10; max-width: 350px; text-shadow: 0 0 3px #00d4ff; }
        #pause-menu { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 50, 0.9); padding: 20px; border-radius: 10px; z-index: 100; display: none; text-align: center; }
        #race-status { position: absolute; top: 20px; right: 20px; color: #00d4ff; font-size: 1.5rem; z-index: 10; }
        @media (max-width: 1024px) {
            #intro h1, #option-mode h1 { font-size: 2.3rem; }
            #intro p, #option-mode p { font-size: 1rem; }
            #start-button, .option-button, #enter-button, #generate-code, #join-game { font-size: 1.2rem; padding: 8px 12px; }
            #footer { font-size: 0.9rem; }
            #joystick-container { width: 70px; height: 70px; bottom: 10px; right: 10px; }
            #joystick { width: 35px; height: 35px; top: 17.5px; left: 17.5px; }
        }
        @media (max-width: 600px) {
            #intro h1, #option-mode h1 { font-size: 1.5rem; }
            #intro p, #option-mode p { font-size: 0.9rem; }
            #start-button, .option-button, #enter-button, #generate-code, #join-game { font-size: 1rem; padding: 6px 8px; }
            #footer { font-size: 0.8rem; }
            #joystick-container { width: 50px; height: 50px; }
            #joystick { width: 25px; height: 25px; top: 12.5px; left: 12.5px; }
        }
        @media (orientation: landscape) and (max-width: 900px) {
            #intro, #option-mode { flex-direction: row; font-size: 0.9em; }
        }
        /* Safe area for notched devices */
        body { padding-top: env(safe-area-inset-top,0); padding-bottom: env(safe-area-inset-bottom,0); padding-left: env(safe-area-inset-left,0); padding-right: env(safe-area-inset-right,0); }
    </style>
</head>
<body>
    <div id="intro">
        <h1>Cosmic Horizon</h1>
        <p>Rule Moreland’s boundless expanse—valleys, waterfalls, and mist weaving earth to sky—blazing at warp speed in this retro-futuristic epic!</p>
        <div id="start-button">Tap to Start</div>
        <div id="footer">Designed by Nana Kofi cosmoscoderr@gmail.com</div>
    </div>

    <div id="option-mode">
        <h1>Choose Your Ride</h1>
        <div id="ship-selection"></div>
        <div id="color-selection"></div>
        <div class="option-button" id="solo-mode">Solo Free Fly</div>
        <div id="multiplayer-options">
            <div>
                <div id="join-game">Join Game</div>
                <input type="text" id="join-game-input" placeholder="Enter Code">
            </div>
            <div class="option-button" id="multiplayer-mode">Multiplayer</div>
            <div>
                <div id="generate-code">Generate Code</div>
                <div id="generated-code"></div>
            </div>
        </div>
        <div id="enter-button">Enter</div>
    </div>

    <div id="instructions">
        W/S: Thrust forward/back (Double-tap W for warp) | A/D: Strafe | P: Pause | Esc: Quit | G: Shoot | Joystick/Mouse: Look | Arrow keys: Rotate | +/-: Zoom | Space: Up (3s+ to blast) | Shift: Down | R: Toggle Race
    </div>
    <canvas id="canvas"></canvas>
    <div id="joystick-container">
        <div id="joystick"></div>
    </div>
    <div id="pause-menu">
        <h2>Paused</h2>
        <div class="option-button" id="resume-button">Resume</div>
        <div class="option-button" id="quit-button">Quit</div>
    </div>
    <div id="race-status"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script>
        const intro = document.getElementById('intro');
        const optionMode = document.getElementById('option-mode');
        const canvas = document.getElementById('canvas');
        const startButton = document.getElementById('start-button');
        const shipSelection = document.getElementById('ship-selection');
        const colorSelection = document.getElementById('color-selection');
        const soloMode = document.getElementById('solo-mode');
        const multiplayerMode = document.getElementById('multiplayer-mode');
        const generateCodeButton = document.getElementById('generate-code');
        const joinGameButton = document.getElementById('join-game');
        const joinGameInput = document.getElementById('join-game-input');
        const generatedCodeDisplay = document.getElementById('generated-code');
        const enterButton = document.getElementById('enter-button');
        const pauseMenu = document.getElementById('pause-menu');
        const resumeButton = document.getElementById('resume-button');
        const quitButton = document.getElementById('quit-button');
        const raceStatus = document.getElementById('race-status');

        let selectedShip = null, selectedColor = null, gameMode = null, gameCode = null, isPaused = false, isHost = false;
        let peer = null, connections = [], myId = null, peerShips = {}, isRaceMode = false, raceStartTime = 0, raceFinishLine;

        const ships = [
            { name: 'Classic', perk: 'Balanced', color: 0xaaaaaa, gun: 'Standard', speed: 8.0 },
            { name: 'Blaster', perk: 'Rapid Fire', color: 0xff5555, gun: 'Rapid', speed: 8.2 },
            { name: 'Tank', perk: 'High Durability', color: 0x5555ff, gun: 'Heavy', speed: 8.0 },
            { name: 'Stealth', perk: 'Fast Reload', color: 0x55ff55, gun: 'Quick', speed: 8.1 },
            { name: 'Sniper', perk: 'Long Range', color: 0xffff55, gun: 'Sniper', speed: 8.0 },
            { name: 'Bomber', perk: 'Explosive Shots', color: 0xff55ff, gun: 'Explosive', speed: 8.2 }
        ];
        const colors = [0xaaaaaa, 0xff5555, 0x5555ff, 0x55ff55, 0xffff55, 0xff55ff];

        ships.forEach((ship, index) => {
            const div = document.createElement('div');
            div.className = 'ship-option';
            div.style.backgroundColor = `#${ship.color.toString(16).padStart(6, '0')}`;
            div.innerText = ship.name;
            div.addEventListener('click', () => {
                document.querySelectorAll('.ship-option').forEach(opt => opt.classList.remove('selected'));
                div.classList.add('selected');
                selectedShip = index;
            });
            shipSelection.appendChild(div);
        });

        colors.forEach(color => {
            const div = document.createElement('div');
            div.className = 'color-option';
            div.style.backgroundColor = `#${color.toString(16).padStart(6, '0')}`;
            div.addEventListener('click', () => {
                document.querySelectorAll('.color-option').forEach(opt => opt.classList.remove('selected'));
                div.classList.add('selected');
                selectedColor = color;
            });
            colorSelection.appendChild(div);
        });

        startButton.addEventListener('click', () => {
            intro.style.display = 'none';
            optionMode.style.display = 'flex';
        });

        soloMode.addEventListener('click', () => { 
            gameMode = 'solo'; 
            soloMode.style.background = '#00d4ff'; 
            multiplayerMode.style.background = ''; 
            gameCode = null; 
            generatedCodeDisplay.innerText = ''; 
            joinGameInput.value = '';
            isHost = false;
        });

        multiplayerMode.addEventListener('click', () => { 
            gameMode = 'multiplayer'; 
            multiplayerMode.style.background = '#00d4ff'; 
            soloMode.style.background = ''; 
        });

        generateCodeButton.addEventListener('click', () => {
            if (gameMode === 'multiplayer') {
                gameCode = Math.random().toString(36).substr(2, 6).toUpperCase();
                generatedCodeDisplay.innerText = `Code: ${gameCode}`;
                isHost = true;
            }
        });

        joinGameButton.addEventListener('click', () => {
            if (gameMode === 'multiplayer' && joinGameInput.value) {
                gameCode = joinGameInput.value.toUpperCase();
                generatedCodeDisplay.innerText = `Joining: ${gameCode}`;
                isHost = false;
            }
        });

        enterButton.addEventListener('click', () => {
            if (selectedShip === null || selectedColor === null) {
                alert('Please select a ship and color!');
                return;
            }
            if (gameMode === 'solo' || (gameMode === 'multiplayer' && gameCode)) {
                optionMode.style.display = 'none';
                canvas.style.display = 'block';
                init();
            } else if (gameMode === 'multiplayer') {
                alert('Please generate a code or join a game first!');
            }
        });

        resumeButton.addEventListener('click', () => togglePause(false));
        quitButton.addEventListener('click', () => {
            isPaused = false;
            pauseMenu.style.display = 'none';
            canvas.style.display = 'none';
            optionMode.style.display = 'flex';
            cleanupMultiplayer();
        });

        let camera, scene, renderer, ship, skyMaterial, fogMaterial, cosmicLights = [], npcShips = [], waterfalls = [], fogParticles, obstacles = [], bullets = [];
        let velocity = new THREE.Vector3();
        let maxSpeed = ships[0].speed, baseAccel = 2.0, boostAccel = 6.0, friction = 0.95, liftSpeed = 4.0, blastSpeed = 40, verticalSpeed = 4.0;
        let keys = { w: false, s: false, a: false, d: false, space: false, shift: false, p: false, g: false, escape: false, r: false };
        let isUserInteracting = false, onPointerDownMouseX = 0, onPointerDownMouseY = 0, lon = 0, onPointerDownLon = 0, lat = 0, onPointerDownLat = 0, targetLon = 0, targetLat = 0, phi = 0, theta = 0;
        let joystick, joystickRect, joystickCenterX, joystickCenterY, joystickActive = false, joystickTouchId = null;
        let time = 0, spaceHoldTime = 0, cycleTime = 0, cameraDistance = 15, cameraHeight = 5, lastWTime = 0, wTapCount = 0, boostEndTime = 0;

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 4000);
            camera.position.set(0, 10, 15);

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            maxSpeed = ships[selectedShip].speed;
            createCosmicSky();
            createTerrain();
            createVolumetricFog();
            createShip();
            createSkyscraper();
            createNPCShips();
            createObstacles();
            if (isHost && gameMode === 'multiplayer') createRaceFinishLine();
            setupJoystick();
            setupControls();

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('pointerdown', onPointerDown);
            document.addEventListener('pointermove', onPointerMove);
            document.addEventListener('pointerup', onPointerUp);

            if (gameMode === 'multiplayer') setupMultiplayer();
            animate();
        }

        function setupMultiplayer() {
            console.log('Setting up multiplayer...');
            peer = new Peer(isHost ? gameCode : null, {
                debug: 2 // Enable PeerJS debug logs
            });

            peer.on('open', (id) => {
                myId = id;
                console.log(`Peer opened with ID: ${id}, isHost: ${isHost}, Code: ${gameCode}`);
                if (!isHost) {
                    console.log(`Attempting to connect to host with code: ${gameCode}`);
                    const conn = peer.connect(gameCode, { reliable: true });
                    setupConnection(conn);
                }
            });

            peer.on('connection', (conn) => {
                console.log(`Incoming connection from ${conn.peer}`);
                if (isHost) {
                    setupConnection(conn);
                }
            });

            peer.on('error', (err) => {
                console.error('PeerJS Error:', err.type, err);
                if (err.type === 'peer-unavailable') {
                    alert('Host not found! Check the code and try again.');
                    cleanupMultiplayer();
                    optionMode.style.display = 'flex';
                    canvas.style.display = 'none';
                }
            });

            // Start syncing after a short delay to ensure ship exists
            setTimeout(() => {
                console.log('Starting position sync...');
                setInterval(syncShipData, 33); // ~30 FPS
            }, 1000);
        }

        function setupConnection(conn) {
            connections.push(conn);
            conn.on('open', () => {
                console.log(`Connection established with ${conn.peer}`);
                const initialData = {
                    type: 'init',
                    id: myId,
                    color: selectedColor,
                    pos: ship ? ship.position.toArray() : [0, 100, 0],
                    rot: ship ? ship.rotation.toArray() : [0, 0, 0]
                };
                conn.send(initialData);
                console.log(`Sent initial data to ${conn.peer}:`, initialData);
            });

            conn.on('data', (data) => {
                console.log(`Received data from ${conn.peer}:`, data);
                if (data.id && data.pos && data.rot) {
                    updatePeerShip(data);
                }
            });

            conn.on('close', () => {
                console.log(`Connection closed with ${conn.peer}`);
                connections = connections.filter(c => c !== conn);
                if (peerShips[conn.peer]) {
                    scene.remove(peerShips[conn.peer]);
                    delete peerShips[conn.peer];
                    console.log(`Removed ship for ${conn.peer}`);
                }
            });

            conn.on('error', (err) => {
                console.error(`Connection error with ${conn.peer}:`, err);
            });
        }

        function syncShipData() {
            if (!ship || !myId || connections.length === 0 || isPaused) {
                console.log('Sync skipped:', { hasShip: !!ship, hasId: !!myId, connections: connections.length, isPaused });
                return;
            }

            const data = {
                type: 'update',
                id: myId,
                pos: ship.position.toArray(),
                rot: ship.rotation.toArray(),
                color: selectedColor,
                raceMode: isRaceMode,
                raceTime: isRaceMode && isHost ? (performance.now() - raceStartTime) / 1000 : undefined
            };

            connections.forEach(conn => {
                if (conn.open) {
                    conn.send(data);
                    console.log(`Sent update to ${conn.peer}:`, data.pos);
                } else {
                    console.log(`Connection to ${conn.peer} not open`);
                }
            });
        }

        function updatePeerShip(data) {
            const peerId = data.id;
            if (!peerId || peerId === myId) return; // Ignore own data

            if (!peerShips[peerId]) {
                console.log(`Creating new ship for ${peerId}`);
                peerShips[peerId] = createPeerShip(data.color);
                scene.add(peerShips[peerId]); // Ensure it's added to the scene
            }

            const peerShip = peerShips[peerId];
            const targetPos = new THREE.Vector3().fromArray(data.pos);
            peerShip.position.lerp(targetPos, 0.5); // Smooth movement
            peerShip.rotation.fromArray(data.rot);
            console.log(`Updated ${peerId} to pos:`, peerShip.position.toArray());

            if (data.raceMode && !isRaceMode && !isHost) {
                isRaceMode = true;
                if (!raceFinishLine) createRaceFinishLine();
                raceStartTime = performance.now() - (data.raceTime * 1000);
            }
        }

        function createPeerShip(color) {
            const shipGroup = new THREE.Group();
            const baseGeometry = new THREE.CylinderGeometry(3, 2.5, 0.8, 16, 1);
            const baseMaterial = new THREE.MeshPhongMaterial({ color, shininess: 50 });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            shipGroup.add(base);
            const domeGeometry = new THREE.SphereGeometry(1.5, 16, 8);
            const domeMaterial = new THREE.MeshPhongMaterial({ color: 0x00ffaa, transparent: true, opacity: 0.8, shininess: 100 });
            const dome = new THREE.Mesh(domeGeometry, domeMaterial);
            dome.position.y = 0.8;
            shipGroup.add(dome);
            const ringGeometry = new THREE.TorusGeometry(2, 0.2, 6, 16);
            const ringMaterial = new THREE.MeshBasicMaterial({ color, emissive: color });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = -0.1;
            shipGroup.add(ring);
            console.log(`Created peer ship with color ${color.toString(16)}`);
            return shipGroup;
        }

        function cleanupMultiplayer() {
            if (peer) {
                connections.forEach(conn => conn.close());
                peer.destroy();
                peer = null;
                connections = [];
                myId = null;
            }
            Object.values(peerShips).forEach(peerShip => scene.remove(peerShip));
            peerShips = {};
            if (raceFinishLine) scene.remove(raceFinishLine);
            raceFinishLine = null;
            isRaceMode = false;
            raceStatus.innerText = '';
            console.log('Multiplayer cleaned up');
        }

        function createRaceFinishLine() {
            const geometry = new THREE.RingGeometry(20, 25, 32);
            const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
            raceFinishLine = new THREE.Mesh(geometry, material);
            raceFinishLine.position.set(500, 50, 500);
            raceFinishLine.rotation.x = Math.PI / 2;
            scene.add(raceFinishLine);
        }

        function animate() {
            if (isPaused) return requestAnimationFrame(animate);
            requestAnimationFrame(animate);
            updateCosmicEnvironment();
            updateMovement();
            updateCamera();
            updateBullets();
            if (isRaceMode) updateRace();
            renderer.render(scene, camera);
        }

        function updateRace() {
            if (raceFinishLine && ship.position.distanceTo(raceFinishLine.position) < 25) {
                const timeTaken = (performance.now() - raceStartTime) / 1000;
                raceStatus.innerText = `Race Finished! Time: ${timeTaken.toFixed(2)}s`;
                isRaceMode = false;
                scene.remove(raceFinishLine);
                raceFinishLine = null;
            } else if (isRaceMode) {
                const timeElapsed = (performance.now() - raceStartTime) / 1000;
                raceStatus.innerText = `Race Time: ${timeElapsed.toFixed(2)}s`;
            }
        }

        function createCosmicSky() {
            const skyGeometry = new THREE.SphereGeometry(3000, 32, 32);
            skyGeometry.scale(-1, 1, 1);
            const uniforms = { time: { value: 0 }, baseColor: { value: new THREE.Vector3(0.05, 0.1, 0.3) }, pulseIntensity: { value: 0.5 }, dayNight: { value: 0 } };
            const vertexShader = `varying vec3 vWorldPosition; void main() { vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`;
            const fragmentShader = `uniform float time; uniform vec3 baseColor; uniform float pulseIntensity; uniform float dayNight; varying vec3 vWorldPosition; void main() { vec3 dir = normalize(vWorldPosition); float noise = sin(dir.x * 3.0 + time) * cos(dir.y * 3.0 + time) * 0.5; vec3 nightColor = mix(baseColor, vec3(0.8, 0.4, 0.6), noise + 0.5); vec3 dayColor = mix(vec3(0.7, 0.9, 1.0), vec3(1.0, 1.0, 0.9), noise + 0.5); vec3 color = mix(nightColor, dayColor, dayNight); float pulse = sin(time * 0.5 + dir.z * 5.0) * pulseIntensity * (1.0 - dayNight); gl_FragColor = vec4(color + pulse * 0.3, 1.0); }`;
            skyMaterial = new THREE.ShaderMaterial({ uniforms, vertexShader, fragmentShader, side: THREE.BackSide });
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);

            for (let i = 0; i < 3; i++) {
                const lightGeometry = new THREE.SphereGeometry(8 - i * 2, 16, 16);
                const lightMaterial = new THREE.MeshBasicMaterial({ color: i === 0 ? 0xffaa88 : i === 1 ? 0x88ccff : 0xffff88 });
                const light = new THREE.Mesh(lightGeometry, lightMaterial);
                scene.add(light);
                cosmicLights.push(light);
                const pointLight = new THREE.PointLight(lightMaterial.color, 2, 1500);
                pointLight.castShadow = true;
                pointLight.shadow.mapSize.width = 1024;
                pointLight.shadow.mapSize.height = 1024;
                light.add(pointLight);
            }

            const particleGeometry = new THREE.BufferGeometry();
            const particleVertices = [];
            for (let i = 0; i < 8000; i++) particleVertices.push((Math.random() - 0.5) * 3500, Math.random() * 1500 + 50, (Math.random() - 0.5) * 3500);
            particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particleVertices, 3));
            const particleMaterial = new THREE.PointsMaterial({ color: 0xaaaaff, size: 2, transparent: true, blending: THREE.AdditiveBlending });
            scene.add(new THREE.Points(particleGeometry, particleMaterial));
            scene.add(new THREE.AmbientLight(0x404060, 0.6));
        }

        function createTerrain() {
            const groundGeometry = new THREE.PlaneGeometry(8000, 8000, 512, 512);
            groundGeometry.rotateX(-Math.PI / 2);
            const vertices = groundGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i], z = vertices[i + 2];
                const distance = Math.sqrt(x * x + z * z);
                vertices[i + 1] = fractalNoise(x, z) * Math.max(0, 1 - distance / 3500);
            }
            groundGeometry.computeVertexNormals();
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x1e2a4a, roughness: 0.7, metalness: 0.2, emissive: 0x102030, emissiveIntensity: 0.8, vertexColors: true });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.receiveShadow = true;
            scene.add(ground);

            for (let i = 0; i < 12; i++) {
                const x = (Math.random() - 0.5) * 7000, z = (Math.random() - 0.5) * 7000, y = fractalNoise(x, z);
                if (y < -15) createWaterfall(x, y + 20, z);
            }
            addEnvironmentDetails();
        }

        function createShip() {
            const shipGroup = new THREE.Group();
            const baseGeometry = new THREE.CylinderGeometry(3, 2.5, 0.8, 16, 1);
            const baseMaterial = new THREE.MeshPhongMaterial({ color: selectedColor, shininess: 50 });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.castShadow = true;
            shipGroup.add(base);

            const domeGeometry = new THREE.SphereGeometry(1.5, 16, 8);
            const domeMaterial = new THREE.MeshPhongMaterial({ color: 0x00ffaa, transparent: true, opacity: 0.8, shininess: 100 });
            const dome = new THREE.Mesh(domeGeometry, domeMaterial);
            dome.position.y = 0.8;
            dome.castShadow = true;
            shipGroup.add(dome);

            const ringGeometry = new THREE.TorusGeometry(2, 0.2, 6, 16);
            const ringMaterial = new THREE.MeshBasicMaterial({ color: selectedColor, emissive: selectedColor });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = -0.1;
            shipGroup.add(ring);

            if (gameMode === 'multiplayer' && gameCode) {
                const plateGeometry = new THREE.PlaneGeometry(2, 0.5);
                const plateMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
                const plate = new THREE.Mesh(plateGeometry, plateMaterial);
                plate.position.set(0, 0, 2.5);
                plate.rotation.y = Math.PI;

                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, 256, 64);
                ctx.fillStyle = '#00d4ff';
                ctx.font = 'bold 40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(gameCode, 128, 45);
                const texture = new THREE.CanvasTexture(canvas);
                plate.material.map = texture;
                plate.material.needsUpdate = true;
                shipGroup.add(plate);
            }

            shipGroup.position.set(0, 100, 0);
            shipGroup.userData = { health: ships[selectedShip].perk === 'High Durability' ? 2 : 1, lastShot: 0, gunType: ships[selectedShip].gun };
            scene.add(shipGroup);
            ship = shipGroup;
        }

        function createObstacles() {
            const numObstacles = gameMode === 'solo' ? 20 : 10;
            for (let i = 0; i < numObstacles; i++) {
                const obstacleGeometry = new THREE.BoxGeometry(10, 10, 10);
                const obstacleMaterial = new THREE.MeshBasicMaterial({ color: 0xff5555 });
                const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
                obstacle.position.set((Math.random() - 0.5) * 7000, Math.random() * 100 + 50, (Math.random() - 0.5) * 7000);
                obstacle.userData = { health: 3 };
                scene.add(obstacle);
                obstacles.push(obstacle);
            }
        }

        function shoot() {
            const now = performance.now();
            const cooldown = ships[selectedShip].perk === 'Fast Reload' ? 200 : ships[selectedShip].perk === 'Rapid Fire' ? 100 : 500;
            if (now - ship.userData.lastShot < cooldown) return;
            ship.userData.lastShot = now;

            const bulletGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xff00ff });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            bullet.position.copy(ship.position);
            const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            bullet.userData = { velocity: direction.clone().multiplyScalar(ships[selectedShip].perk === 'Long Range' ? 30 : 20), type: ships[selectedShip].gun, damage: ships[selectedShip].perk === 'Explosive Shots' ? 2 : 1 };
            scene.add(bullet);
            bullets.push(bullet);
        }

        function togglePause(state) {
            isPaused = state;
            pauseMenu.style.display = state ? 'block' : 'none';
        }

        function setupControls() {
            document.addEventListener('keydown', (e) => {
                switch (e.key.toLowerCase()) {
                    case 'w': keys.w = true; const now = performance.now(); if (now - lastWTime < 300) { wTapCount++; if (wTapCount >= 2) boostEndTime = now + 800; } else wTapCount = 1; lastWTime = now; break;
                    case 's': keys.s = true; break;
                    case 'a': keys.a = true; break;
                    case 'd': keys.d = true; break;
                    case ' ': keys.space = true; spaceHoldTime = performance.now(); break;
                    case 'shift': keys.shift = true; break;
                    case 'p': if (!keys.p) togglePause(!isPaused); keys.p = true; break;
                    case 'g': keys.g = true; shoot(); break;
                    case 'r': if (!keys.r) { isRaceMode = !isRaceMode; if (isRaceMode && !raceFinishLine) { createRaceFinishLine(); raceStartTime = performance.now(); } } keys.r = true; break;
                    case 'escape': if (!isPaused) togglePause(true); else if (confirm('Quit to menu?')) quitButton.click(); break;
                    case '+': case '=': cameraDistance = Math.max(5, cameraDistance - 1); break;
                    case '-': cameraDistance = Math.min(30, cameraDistance + 1); break;
                }
            });
            document.addEventListener('keyup', (e) => {
                switch (e.key.toLowerCase()) {
                    case 'w': keys.w = false; break;
                    case 's': keys.s = false; break;
                    case 'a': keys.a = false; break;
                    case 'd': keys.d = false; break;
                    case ' ': keys.space = false; const holdDuration = (performance.now() - spaceHoldTime) / 1000; if (holdDuration >= 3) velocity.y += blastSpeed; break;
                    case 'shift': keys.shift = false; break;
                    case 'p': keys.p = false; break;
                    case 'g': keys.g = false; break;
                    case 'r': keys.r = false; break;
                }
            });
            document.addEventListener('keydown', onKeyDown);
        }

        function updateBullets() {
            bullets.forEach((bullet, index) => {
                bullet.position.add(bullet.userData.velocity);
                if (bullet.position.distanceTo(ship.position) > 1000) {
                    scene.remove(bullet);
                    bullets.splice(index, 1);
                    return;
                }

                obstacles.forEach(obstacle => {
                    if (bullet.position.distanceTo(obstacle.position) < 5) {
                        obstacle.userData.health -= bullet.userData.damage;
                        if (obstacle.userData.health <= 0) {
                            scene.remove(obstacle);
                            obstacles.splice(obstacles.indexOf(obstacle), 1);
                        }
                        scene.remove(bullet);
                        bullets.splice(index, 1);
                    }
                });

                if (gameMode === 'multiplayer') {
                    Object.values(peerShips).forEach(peerShip => {
                        if (bullet.position.distanceTo(peerShip.position) < 5) {
                            scene.remove(bullet);
                            bullets.splice(index, 1);
                        }
                    });
                }
            });
        }

        function fractalNoise(x, z, octaves = 8) {
            let total = 0, frequency = 0.015, amplitude = 1, maxValue = 0;
            for (let i = 0; i < octaves; i++) {
                total += Math.sin(x * frequency) * Math.cos(z * frequency) * amplitude;
                total += Math.random() * 0.6 * amplitude;
                maxValue += amplitude;
                amplitude *= 0.6;
                frequency *= 2.3;
            }
            return total / maxValue * 80 - 30;
        }

        function createWaterfall(x, y, z) {
            const particleGeometry = new THREE.BufferGeometry();
            const particleVertices = [];
            for (let i = 0; i < 400; i++) {
                particleVertices.push(x + (Math.random() - 0.5) * 12, y - Math.random() * 25, z + (Math.random() - 0.5) * 12);
            }
            particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particleVertices, 3));
            const particleMaterial = new THREE.PointsMaterial({ color: 0x88ccff, size: 0.6, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
            const waterfall = new THREE.Points(particleGeometry, particleMaterial);
            waterfall.userData = { baseY: y, speed: 0.12, baseX: x, baseZ: z };
            scene.add(waterfall);
            waterfalls.push(waterfall);
        }

        function createVolumetricFog() {
            const fogGeometry = new THREE.PlaneGeometry(10000, 10000);
            fogGeometry.rotateX(-Math.PI / 2);
            const fogUniforms = { time: { value: 0 }, color: { value: new THREE.Color(0xaaffcc) }, fogDensity: { value: 0.015 } };
            const fogVertexShader = `varying vec3 vWorldPosition; void main() { vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`;
            const fogFragmentShader = `uniform float time; uniform vec3 color; uniform float fogDensity; varying vec3 vWorldPosition; vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; } vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; } vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); } vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; } float snoise(vec3 v) { const vec2 C = vec2(1.0/6.0, 1.0/3.0); const vec4 D = vec4(0.0, 0.5, 1.0, 2.0); vec3 i = floor(v + dot(v, C.yyy)); vec3 x0 = v - i + dot(i, C.xxx); vec3 g = step(x0.yzx, x0.xyz); vec3 l = 1.0 - g; vec3 i1 = min(g.xyz, l.zxy); vec3 i2 = max(g.xyz, l.zxy); vec3 x1 = x0 - i1 + C.xxx; vec3 x2 = x0 - i2 + C.yyy; vec3 x3 = x0 - D.yyy; i = mod289(i); vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0)); float n_ = 0.142857142857; vec3 ns = n_ * D.wyz - D.xzx; vec4 j = p - 49.0 * floor(p * ns.z * ns.z); vec4 x_ = floor(j * ns.z); vec4 y_ = floor(j - 7.0 * x_); vec4 x = x_ *ns.x + ns.yyyy; vec4 y = y_ *ns.x + ns.yyyy; vec4 h = 1.0 - abs(x) - abs(y); vec4 b0 = vec4(x.xy, y.xy); vec4 b1 = vec4(x.zw, y.zw); vec4 s0 = floor(b0)*2.0 + 1.0; vec4 s1 = floor(b1)*2.0 + 1.0; vec4 sh = -step(h, vec4(0.0)); vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy; vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww; vec3 p0 = vec3(a0.xy, h.x); vec3 p1 = vec3(a0.zw, h.y); vec3 p2 = vec3(a1.xy, h.z); vec3 p3 = vec3(a1.zw, h.w); vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3))); p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w; vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0); m = m * m; return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3))); } void main() { vec3 pos = vWorldPosition; float noise = snoise(pos * 0.04 + vec3(0.0, time * 0.08, 0.0)) * 0.5 + 0.5; float heightFade = smoothstep(-30.0, 80.0, pos.y); float density = fogDensity * noise * (1.0 - heightFade); gl_FragColor = vec4(color, density); }`;
            fogMaterial = new THREE.ShaderMaterial({ uniforms: fogUniforms, vertexShader: fogVertexShader, fragmentShader: fogFragmentShader, transparent: true, side: THREE.DoubleSide });
            const fogLayer = new THREE.Mesh(fogGeometry, fogMaterial);
            fogLayer.position.y = 25;
            scene.add(fogLayer);

            const fogParticleGeometry = new THREE.BufferGeometry();
            const fogParticleVertices = [];
            for (let i = 0; i < 3000; i++) fogParticleVertices.push((Math.random() - 0.5) * 8000, Math.random() * 100, (Math.random() - 0.5) * 8000);
            fogParticleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(fogParticleVertices, 3));
            const fogParticleMaterial = new THREE.PointsMaterial({ color: 0xaaffcc, size: 6, transparent: true, opacity: 0.25, blending: THREE.AdditiveBlending });
            fogParticles = new THREE.Points(fogParticleGeometry, fogParticleMaterial);
            scene.add(fogParticles);
        }

        function createSkyscraper() {
            const skyscraperGroup = new THREE.Group();
            const towerGeometry = new THREE.CylinderGeometry(5, 5, 100, 16);
            const towerMaterial = new THREE.MeshPhongMaterial({ color: 0x3a5a7a, shininess: 50 });
            const tower = new THREE.Mesh(towerGeometry, towerMaterial);
            tower.position.y = 50;
            tower.castShadow = true;
            tower.receiveShadow = true;
            skyscraperGroup.add(tower);

            const platformGeometry = new THREE.CircleGeometry(10, 16);
            const platformMaterial = new THREE.MeshBasicMaterial({ color: 0x00ccff, emissive: 0x00ccff });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.rotation.x = -Math.PI / 2;
            platform.position.y = 100;
            platform.receiveShadow = true;
            skyscraperGroup.add(platform);

            skyscraperGroup.position.set(0, 0, 0);
            scene.add(skyscraperGroup);
        }

        function createNPCShips() {
            const colors = [0xffaa88, 0x88ccff, 0xddaaff, 0xffff88, 0xff88ff];
            for (let i = 0; i < 8; i++) {
                const npcShip = new THREE.Group();
                const baseGeometry = new THREE.CylinderGeometry(3, 2.5, 0.8, 16, 1);
                const baseMaterial = new THREE.MeshPhongMaterial({ color: colors[i % 5], shininess: 50 });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.castShadow = true;
                npcShip.add(base);

                const domeGeometry = new THREE.SphereGeometry(1.5, 16, 8);
                const domeMaterial = new THREE.MeshPhongMaterial({ color: 0x00ffaa, transparent: true, opacity: 0.8, shininess: 100 });
                const dome = new THREE.Mesh(domeGeometry, domeMaterial);
                dome.position.y = 0.8;
                dome.castShadow = true;
                npcShip.add(dome);

                const ringGeometry = new THREE.TorusGeometry(2, 0.2, 6, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({ color: colors[i % 5], emissive: colors[i % 5] });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI / 2;
                ring.position.y = -0.1;
                npcShip.add(ring);

                npcShip.position.set(Math.random() * 2000 - 1000, 50 + Math.random() * 150, Math.random() * 2000 - 1000);
                npcShip.userData = { speed: Math.random() * 0.05 + 0.03, orbitRadius: Math.random() * 600 + 300, orbitAngle: Math.random() * Math.PI * 2, heightAngle: Math.random() * Math.PI };
                scene.add(npcShip);
                npcShips.push(npcShip);
            }
        }

        function addEnvironmentDetails() {
            for (let i = 0; i < 30; i++) {
                const orbGeometry = new THREE.SphereGeometry(Math.random() * 4 + 2, 12, 12);
                const orbMaterial = new THREE.MeshBasicMaterial({ color: 0x88ccff, transparent: true, opacity: 0.75 });
                const orb = new THREE.Mesh(orbGeometry, orbMaterial);
                orb.position.set(Math.random() * 7000 - 3500, Math.random() * 100 + 150, Math.random() * 7000 - 3500);
                orb.userData = { speed: Math.random() * 0.015 + 0.01, hover: Math.random() * 3 };
                scene.add(orb);
            }

            function createSpire(x, z) {
                const baseGeometry = new THREE.CylinderGeometry(0.5, 0.8, 6, 6);
                const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x3a5a7a, roughness: 0.65 });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.set(x, fractalNoise(x, z) + 3, z);
                base.castShadow = true;

                const spireGeometry = new THREE.TetrahedronGeometry(3, 0);
                const spireMaterial = new THREE.MeshPhongMaterial({ color: 0x00aaff, emissive: 0x0077cc, shininess: 100, transparent: true, opacity: 0.9 });
                const spire = new THREE.Mesh(spireGeometry, spireMaterial);
                spire.position.set(x, fractalNoise(x, z) + 7, z);
                spire.castShadow = true;
                spire.rotation.y = Math.random() * Math.PI;

                scene.add(base, spire);
            }

            for (let i = 0; i < 100; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 2000 + 500;
                createSpire(Math.cos(angle) * radius, Math.sin(angle) * radius);
            }

            for (let i = 0; i < 15; i++) {
                const poolGeometry = new THREE.CircleGeometry(12 + Math.random() * 6, 16);
                const poolMaterial = new THREE.MeshBasicMaterial({ color: 0x00ccff, emissive: 0x00ccff, transparent: true, opacity: 0.6 });
                const pool = new THREE.Mesh(poolGeometry, poolMaterial);
                pool.rotation.x = -Math.PI / 2;
                const x = Math.random() * 7000 - 3500;
                const z = Math.random() * 7000 - 3500;
                pool.position.set(x, fractalNoise(x, z) + 0.1, z);
                scene.add(pool);
            }

            for (let i = 0; i < 8; i++) {
                const islandGeometry = new THREE.PlaneGeometry(40 + Math.random() * 20, 40 + Math.random() * 20, 12, 12);
                islandGeometry.rotateX(-Math.PI / 2);
                const vertices = islandGeometry.attributes.position.array;
                for (let j = 0; j < vertices.length; j += 3) vertices[j + 1] += Math.random() * 10 - 5;
                islandGeometry.computeVertexNormals();
                const islandMaterial = new THREE.MeshStandardMaterial({ color: 0x304a7a, roughness: 0.9 });
                const island = new THREE.Mesh(islandGeometry, islandMaterial);
                island.position.set(Math.random() * 7000 - 3500, 80 + Math.random() * 80, Math.random() * 7000 - 3500);
                island.castShadow = true;
                island.receiveShadow = true;
                scene.add(island);
            }

            for (let i = 0; i < 40; i++) {
                const crystalGeometry = new THREE.TetrahedronGeometry(3 + Math.random() * 2, 1);
                const crystalMaterial = new THREE.MeshPhongMaterial({ color: 0x00ffcc, emissive: 0x00cc99, shininess: 80, transparent: true, opacity: 0.85 });
                const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                const x = Math.random() * 7000 - 3500;
                const z = Math.random() * 7000 - 3500;
                crystal.position.set(x, fractalNoise(x, z) + 3, z);
                crystal.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                crystal.castShadow = true;
                scene.add(crystal);
            }
        }

        function setupJoystick() {
            joystick = document.getElementById('joystick');
            const joystickContainer = document.getElementById('joystick-container');
            joystickRect = joystickContainer.getBoundingClientRect();
            joystickCenterX = joystickRect.left + joystickRect.width / 2;
            joystickCenterY = joystickRect.top + joystickRect.height / 2;

            joystickContainer.addEventListener('pointerdown', onJoystickStart, { passive: false });
            document.addEventListener('pointermove', onJoystickMove, { passive: false });
            document.addEventListener('pointerup', onJoystickEnd);
            document.addEventListener('pointercancel', onJoystickEnd);
        }

        function onJoystickStart(event) {
            event.preventDefault();
            if (!joystickActive) {
                joystickActive = true;
                joystickTouchId = event.pointerId;
                joystick.style.transition = 'none';
                updateJoystickPosition(event.clientX, event.clientY);
            }
        }

        function onJoystickMove(event) {
            if (joystickActive && event.pointerId === joystickTouchId) {
                event.preventDefault();
                updateJoystickPosition(event.clientX, event.clientY);
            }
        }

        function onJoystickEnd(event) {
            if (joystickActive && event.pointerId === joystickTouchId) {
                joystickActive = false;
                joystick.style.transition = '0.2s';
                joystick.style.left = '25px';
                joystick.style.top = '25px';
                targetLon = lon;
                targetLat = lat;
            }
        }

        function updateJoystickPosition(clientX, clientY) {
            joystickRect = document.getElementById('joystick-container').getBoundingClientRect();
            joystickCenterX = joystickRect.left + joystickRect.width / 2;
            joystickCenterY = joystickRect.top + joystickRect.height / 2;

            let deltaX = clientX - joystickCenterX;
            let deltaY = clientY - joystickCenterY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const maxRadius = joystickRect.width / 2 - joystick.offsetWidth / 2;
            if (distance > maxRadius) {
                deltaX = deltaX * maxRadius / distance;
                deltaY = deltaY * maxRadius / distance;
            }

            joystick.style.left = (deltaX + joystickRect.width / 2 - joystick.offsetWidth / 2) + 'px';
            joystick.style.top = (deltaY + joystickRect.height / 2 - joystick.offsetHeight / 2) + 'px';

            targetLon += deltaX * 0.25;
            targetLat -= deltaY * 0.25;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            joystickRect = document.getElementById('joystick-container').getBoundingClientRect();
            joystickCenterX = joystickRect.left + joystickRect.width / 2;
            joystickCenterY = joystickRect.top + joystickRect.height / 2;
        }

        function onPointerDown(event) {
            if (event.target.id !== 'joystick' && event.target.id !== 'joystick-container') {
                isUserInteracting = true;
                onPointerDownMouseX = event.clientX;
                onPointerDownMouseY = event.clientY;
                onPointerDownLon = lon;
                onPointerDownLat = lat;
            }
        }

        function onPointerMove(event) {
            if (isUserInteracting) {
                targetLon = (onPointerDownMouseX - event.clientX) * 0.25 + onPointerDownLon;
                targetLat = (event.clientY - onPointerDownMouseY) * 0.25 + onPointerDownLat;
            }
        }

        function onPointerUp() {
            isUserInteracting = false;
        }

        function onKeyDown(event) {
            switch (event.keyCode) {
                case 37: targetLon -= 5; break;
                case 38: targetLat += 5; break;
                case 39: targetLon += 5; break;
                case 40: targetLat -= 5; break;
            }
        }

        function updateCosmicEnvironment() {
            time += 0.012;
            cycleTime += 0.015;

            const cycleDuration = 60;
            const dayNight = Math.sin(cycleTime * Math.PI / cycleDuration) * 0.5 + 0.5;
            skyMaterial.uniforms.time.value = time;
            skyMaterial.uniforms.dayNight.value = dayNight;
            skyMaterial.uniforms.pulseIntensity.value = 0.5 * (1 - dayNight);
            fogMaterial.uniforms.time.value = time;

            cosmicLights[0].position.set(Math.cos(time) * 1000, 600 + Math.sin(time * 0.8) * 120, Math.sin(time) * 1000);
            cosmicLights[1].position.set(Math.cos(time + 2) * 900, 650 + Math.sin(time * 0.9) * 100, Math.sin(time + 2) * 900);
            cosmicLights[2].position.set(Math.cos(time + 4) * 800, 700 + Math.sin(time) * 80, Math.sin(time + 4) * 800);

            scene.children.forEach(child => {
                if (child.userData.speed && !child.userData.orbitRadius && !child.userData.baseY) {
                    child.position.x += child.userData.speed;
                    child.position.y = 150 + Math.sin(time + child.userData.hover) * 12;
                    if (child.position.x > 3500) child.position.x = -3500;
                    child.scale.setScalar(1 + Math.sin(time * 2 + child.userData.hover) * 0.15);
                }
            });

            npcShips.forEach(ship => {
                ship.userData.orbitAngle += ship.userData.speed * 0.015;
                ship.userData.heightAngle += ship.userData.speed * 0.008;
                ship.position.x = Math.cos(ship.userData.orbitAngle) * ship.userData.orbitRadius;
                ship.position.z = Math.sin(ship.userData.orbitAngle) * ship.userData.orbitRadius;
                ship.position.y = 50 + Math.sin(ship.userData.heightAngle) * 120;
                ship.rotation.y += 0.02;
                if (ship.position.x > 4000) ship.position.x = -4000;
                if (ship.position.x < -4000) ship.position.x = 4000;
                if (ship.position.z > 4000) ship.position.z = -4000;
                if (ship.position.z < -4000) ship.position.z = 4000;
            });

            waterfalls.forEach(waterfall => {
                const positions = waterfall.geometry.attributes.position.array;
                for (let i = 1; i < positions.length; i += 3) {
                    positions[i] -= waterfall.userData.speed;
                    if (positions[i] < fractalNoise(positions[i - 1], positions[i + 1])) {
                        positions[i] = waterfall.userData.baseY;
                        positions[i - 1] = waterfall.userData.baseX + (Math.random() - 0.5) * 12;
                        positions[i + 1] = waterfall.userData.baseZ + (Math.random() - 0.5) * 12;
                    }
                }
                waterfall.geometry.attributes.position.needsUpdate = true;
            });

            const fogPositions = fogParticles.geometry.attributes.position.array;
            for (let i = 0; i < fogPositions.length; i += 3) {
                fogPositions[i] += Math.sin(time + fogPositions[i + 1]) * 0.015;
                fogPositions[i + 2] += Math.cos(time + fogPositions[i]) * 0.015;
                if (fogPositions[i] > 4000) fogPositions[i] = -4000;
                if (fogPositions[i] < -4000) fogPositions[i] = 4000;
                if (fogPositions[i + 2] > 4000) fogPositions[i + 2] = -4000;
                if (fogPositions[i + 2] < -4000) fogPositions[i + 2] = 4000;
            }
            fogParticles.geometry.attributes.position.needsUpdate = true;
        }

        function updateMovement() {
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
            const now = performance.now();
            const accel = (now < boostEndTime) ? boostAccel : baseAccel;

            if (keys.w) velocity.add(forward.multiplyScalar(accel));
            if (keys.s) velocity.add(forward.multiplyScalar(-accel));
            if (keys.a) velocity.add(right.multiplyScalar(-accel));
            if (keys.d) velocity.add(right.multiplyScalar(accel));

            if (keys.space) velocity.y += verticalSpeed;
            if (keys.shift) velocity.y -= verticalSpeed;
            if (!keys.space && !keys.shift && Math.abs(velocity.x) < 0.1 && Math.abs(velocity.z) < 0.1) {
                velocity.y = Math.sin(time * 2) * 0.05;
            }

            velocity.clampLength(0, maxSpeed);
            velocity.multiplyScalar(friction);
            ship.position.add(velocity);

            const forwardVel = velocity.dot(forward);
            const rightVel = velocity.dot(right);
            const maxTilt = THREE.MathUtils.degToRad(20);
            ship.rotation.x = THREE.MathUtils.lerp(ship.rotation.x, THREE.MathUtils.clamp(forwardVel * 0.05, -maxTilt, maxTilt), 0.2);
            ship.rotation.z = THREE.MathUtils.lerp(ship.rotation.z, THREE.MathUtils.clamp(-rightVel * 0.05, -maxTilt, maxTilt), 0.2);
            ship.rotation.y = theta;

            const offset = new THREE.Vector3(0, cameraHeight, cameraDistance).applyQuaternion(camera.quaternion);
            camera.position.lerp(ship.position.clone().add(offset), 0.2);
        }

        function updateCamera() {
            lon = THREE.MathUtils.lerp(lon, targetLon, 0.2);
            lat = THREE.MathUtils.lerp(lat, targetLat, 0.2);
            lat = Math.max(-85, Math.min(85, lat));

            phi = THREE.MathUtils.degToRad(90 - lat);
            theta = THREE.MathUtils.degToRad(lon);

            const lookAt = new THREE.Vector3(
                camera.position.x + Math.sin(phi) * Math.cos(theta),
                camera.position.y + Math.cos(phi),
                camera.position.z + Math.sin(phi) * Math.sin(theta)
            );
            camera.lookAt(lookAt);

            const ground = scene.children.find(child => child.isMesh && child.geometry.type === 'PlaneGeometry');
            if (ground) {
                const raycaster = new THREE.Raycaster(ship.position, new THREE.Vector3(0, -1, 0), 0, 20);
                const intersects = raycaster.intersectObject(ground);
                if (intersects.length > 0) {
                    const groundHeight = intersects[0].point.y + 3;
                    if (ship.position.y < groundHeight) {
                        ship.position.y = groundHeight;
                        velocity.y = Math.max(0, velocity.y);
                    }
                }

                const colors = ground.geometry.attributes.color || new THREE.Float32BufferAttribute(new Float32Array(ground.geometry.attributes.position.count * 3), 3);
                const shipX = Math.floor((ship.position.x + 4000) / 8000 * 512);
                const shipZ = Math.floor((ship.position.z + 4000) / 8000 * 512);
                for (let i = 0; i < colors.count; i++) {
                    const dx = Math.abs(i % 512 - shipX);
                    const dz = Math.abs(Math.floor(i / 512) - shipZ);
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    const tint = Math.max(0, 1 - dist / 40);
                    colors.setXYZ(i, 0.12 + tint * 0.1, 0.18 + tint * 0.2, 0.29 + tint * 0.2);
                }
                ground.geometry.setAttribute('color', colors);
                ground.geometry.attributes.color.needsUpdate = true;
            }
        }
    </script>
    <script>
        // --- Responsive Canvas Resize ---
        function resizeGameCanvas() {
            const canvas = document.getElementById('canvas');
            if (canvas) {
                const dpr = window.devicePixelRatio || 1;
                canvas.width = window.innerWidth * dpr;
                canvas.height = window.innerHeight * dpr;
                canvas.style.width = window.innerWidth + 'px';
                canvas.style.height = window.innerHeight + 'px';
            }
        }
        window.addEventListener('resize', resizeGameCanvas);
        window.addEventListener('orientationchange', resizeGameCanvas);
        window.addEventListener('DOMContentLoaded', resizeGameCanvas);

        // --- Touch Controls Polyfill ---
        function enableTouchControls() {
            const joystick = document.getElementById('joystick');
            if (!joystick) return;
            let dragging = false, startX = 0, startY = 0;
            joystick.addEventListener('touchstart', function(e) {
                dragging = true;
                const touch = e.touches[0];
                startX = touch.clientX;
                startY = touch.clientY;
                e.preventDefault();
            }, { passive: false });
            joystick.addEventListener('touchmove', function(e) {
                if (!dragging) return;
                const touch = e.touches[0];
                // Map touch movement to game controls here
                // (example: update movement direction)
                e.preventDefault();
            }, { passive: false });
            joystick.addEventListener('touchend', function(e) {
                dragging = false;
                e.preventDefault();
            }, { passive: false });
        }
        window.addEventListener('DOMContentLoaded', enableTouchControls);

        // --- Lower Particle Count for Low-end Devices ---
        function isLowEndDevice() {
            return /Mobi|Android|iPhone|iPad|iPod|Opera Mini|IEMobile|WPDesktop/i.test(navigator.userAgent);
        }
        let PARTICLE_COUNT = isLowEndDevice() ? 800 : 2000;
        // Use PARTICLE_COUNT in your particle system initialization
    </script>
</body>
</html>
